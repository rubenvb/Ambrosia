/**
 *
 * Project Ambrosia: Ambrosia library
 *
 * Written in 2012 by Ruben Van Boxem <vanboxem.ruben@gmail.com>
 *
 * To the extent possible under law, the author(s) have dedicated all copyright and related
 * and neighboring rights to this software to the public domain worldwide. This software is
 * distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along with this software.
 * If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 *
 * Ambrosia/project.cpp
 * Class implementation.
 *
 **/

// Class include
#include "Ambrosia/project.h"

// libAmbrosia includes
#include "Ambrosia/algorithm.h"
#include "Ambrosia/build_element.h"
#include "Ambrosia/Configuration/ambrosia_config.h"
#include "Ambrosia/debug.h"
#include "Ambrosia/enum_maps.h"
#include "Ambrosia/Error/error.h"
#include "Ambrosia/Error/soft_error.h"
#include "Ambrosia/Generators/compile_and_link_generator.h"
#include "Ambrosia/nectar_loader.h"

// C++ includes
#include <iostream>
  using std::cout;
#include <memory>
  using std::unique_ptr;
#include <string>
  using std::string;
#include <fstream>
  using std::ifstream;

libambrosia_namespace_begin

ambrosia_config* project::configuration = NULL;

project::project(ambrosia_config& ambrosia_config,
                 file_cache& file_cache)
: m_targets(),
  m_file_cache(file_cache),
  m_commands()
{
  configuration = &ambrosia_config;
}
project::project(file_cache& file_cache)
: m_targets(),
  m_file_cache(file_cache),
  m_commands()
{   }

// Filter target_list and sort the targets that need to be built.
void project::apply_target_configuration()
{
  const map_string_set_string target_config = configuration->target_config_options();

  for(auto&& it = std::begin(target_config); it != std::end(target_config); ++it)
  {

  }
  throw error("project::apply_target_configuration::Not yet implemented.");
}

void project::sort_targets()
{
  debug(debug::dependencies) << "project::dependency_sort_targets::Pre-sort order:\n";
  std::for_each(std::begin(m_targets), std::end(m_targets),
                [](const target_ptr& t) { debug(debug::dependencies) << "\t" << t->name << "\n"; });
  /*target_vector resolved;
  while(!m_targets.empty())
  {
    dependency_resolve(std::begin(m_targets), resolved, m_targets);
  }

  m_targets.swap(resolved);*/
  //filter_dependency_sort(m_targets);
  debug(debug::dependencies) << "project::dependency_sort_targets::Post-sort order:\n";
  std::for_each(std::begin(m_targets), std::end(m_targets),
                [](const target_ptr& t) { debug(debug::dependencies) << "\t" << t->name << "\n"; });
}

void project::generate_commands()
{
  // assume targets are in the correct dependent order
  for(auto&& target_it = std::begin(m_targets); target_it != std::end(m_targets); ++target_it)
  {
    target& current = **target_it;
    if(current.m_type == target_type::global)
    {
      debug(debug::command_gen) << "project::generate_commands::Skipping generation of build commands for target: " << current.name << ".\n";
      continue;
    }
    debug(debug::command_gen) << "project::generate_commands::Generating build commands for target: " << current.name << "\n"
                              << "\tfor output in this directory: " << current.m_build_config.m_build_directory << "\n"
                              << "\tfor the following types of source files:\n"
                              << "\t" << current.m_build_config.m_source_types << "\n";

    for(auto&& type_it = std::begin(current.m_build_config.m_source_types); type_it != std::end(current.m_build_config.m_source_types); ++type_it)
    {
      const auto& type = *type_it;
      debug(debug::command_gen) << "project::generate_commands::Generating commands for " << current.files(type).size() << " "
                                << file_type_map_inverse.at(type) << " files.\n";
      //TODO generalize to a "get_generator function when there are languages supported that need a different style of processing
      unique_ptr<generator> generator(new compile_and_link_generator(type, current));

      generator->generate_object_filenames();
      const string_vector commands = generator->generate_parallel_commands();

      //TODO: debug output of commands, or storage in a per-target list for nice output.

      //TODO: fix ugly function call below
      m_commands[current.name].insert(std::end(m_commands[current.name]), std::begin(commands), std::end(commands));
    }
  }
}

void project::dump_commands() const
{
  cout << "Commands generated by Ambrosia:\n";
  for(auto&& target_it = std::begin(m_commands); target_it != std::end(m_commands); ++target_it)
  {
    const string& target_name = target_it->first;
    const auto& commands = target_it->second;

    cout << "-> Commands for target " << target_name << ":\n";

    std::for_each(std::begin(commands), std::end(commands),
                  [](const std::string& command)
                  { cout << command << "\n"; });
  }
  throw soft_error("Execution stopped after dumping commands.");
}

void project::execute_build_commands()
{
  for(auto&& target_it = std::begin(m_commands); target_it != std::end(m_commands); ++target_it)
  {
    const string& target_name = target_it->first;
    auto& commands = target_it->second;
    debug(debug::command_exec) << "project::execute_build_commands::Executing commands for target " << target_name << "\n";
    for(auto&& it = std::begin(commands); it != std::end(commands); ++it)
    {
      string stdout_output;
      string stderr_output;
      execute_command(*it, stdout_output, stderr_output);
      debug(debug::command_exec) << "project::execute_build_commands::Command execution succesful:\n"
                                    "\tcommand was: " << *it << "\n"
                                    "\tstdout: " << stdout_output << "\n"
                                    "\tstderr: " << stderr_output << "\n";
    }
  }
  throw error("execute_build_commands is not implemented yet.");
}

libambrosia_namespace_end
